

#pragma once
#include "../render/RenderableInstance.h"
#include "../util/Math.h"

namespace BasicMM {
	class MicroManager;
};

namespace LargeObjectManager
{
	typedef std::vector< RenderableInstance > RenderableList;

	typedef uint32_t LargeObjectID;
	
	struct GravityGenerator 
	{
		Math::float3	position;
		float		radius;
		float		mass;
		float		maxGravityEffect;
	};
	
	

	void renderVisible( BasicMM::MicroManager & manager );

	void addNewGravityBody( Math::float3 pos, float radius, float mass, float maxGravityEffect, const RenderableInstance & ri );
}

struct Entity {
	Handle GamePosition;
	Handle CollisionData;
	event onCollision;
	event onDeath;
	event onDamage;
};

struct GamePosition {
	Handle Entity;		// 4 byte integer
	Math::float3 pos;		// 3 * 4 byte floats
	Math::float4 rot;		// 4 * 4 byte floats
};							// Total: 32 bytes

// GamePosition and EntityVisual are array syncronized

struct EntityVisual {
	Handle GamePosition;	
	Math::float3 cullbox;
};
// Logic:
//	For each EntityVisual 
//		1. Get gameposition
//		2. Cull based gross position
//		3. Send to render
	

// Logic:
//
// Game Loop (runs at fixed time step)
//  Game to Render --> NewUpdateTimeStep (called every 30 ms)
//		Render: -> reset internal data structures (allows render to interprolate at the current frame speed making animations smoother)
//	Game: Transform( GamePosition + EntityVisual --> CullData ) (send where the item should be at the next game loop)
// End Game Loop
// Render Loop (runs on frame time)
//  Render: Cull( CullData )
//	Render: Increment position from prior to last based on current time till next game loop 
//	Render: Update interbuffers and draw
// End Render Loop


// Updated each frame (associated with renderable)
struct CullData {
	Handle uniqueID; (Generated by using entity handle) 
	Math::Matrix worldspacetransform;
	float sphere;
	float * boxes;
};

struct CollisionData {
	Handle entity;
	Handle GamePosition;
	uint32_t flags;
	uint32_t teams;
	float sphere;		// Creates a full sphere
	float EmptySphere;	// Creates a ring
	float * boxes;		// Collision bounding boxes
};

struct GravityGenerator {
	float maxGravityRadius;
	float mass;
	Handle gameposition;
};
	
struct Movable {
	Math::float3 velocity;
	Math::float3 accleration;
	Handle gameposition;
};



// Seperate Numbers are things in sequence.
// Same number different letter can happen at the same time

1.  Loop over Movable and update GamePosition
2a. Loop over CollisionData and update Entity and update Movable
2b. Loop over GamePosition and send to Render
3.  loop over RenderItems with CullData and do cull 
4.  Render items to screen


// More advanced items

struct AI {
	Handle Entity;
	Handle enemyEntity;
	State machine data;
	event onCollision;
	event onDeath;
}

struct PlanetMotion {
	Math::float3 centerPoint;
	Math::float3 radius;
}


struct Bullet {
	// Velocity is always constant
	// Accleration is always 0
	Handle OwnerEntity;
	Handle Entity;
	Handle GamePosition;
}

struct Missle {
	// Velocity is always changing
	// Accleration is always changing
	Handle GamePosition;
	Handle TrackingEntity;
	Handle OwnerEntity;
	Handle Entity;
	// How to update a missle
	{
		1. Get current position;
		2. Get enemy position;
		3. calculat orientation difference;
		3.5 calculate distance. If too far then look for new enemyEntity 
		4. Turn by max amount;
		5. set accleration --> Movable;
	}
};

struct Explosion {
	Handle GamePosition;
	float ringSize;
	float forcePush;
	float initalDamage;
	float attenuation;
	// How to update explosion
	{
		1. Expand ringSize
		2. If initalDamage - attenuation = 0 end explosion
		3. Update collision data
		4. If collision happens store entity and ignore it for the next force push
	}
}

struct BlackHole {
	Handle Entity;
	Handle GravityGenerator;
	Handle OwnerEntity;
	float TimeToEnd;
}


}