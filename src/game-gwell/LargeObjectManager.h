

#pragma once
/*
#include "../render/RenderableInstance.h"
#include "../util/Math.h"

namespace BasicMM {
	class MicroManager;
};

namespace LargeObjectManager
{
	typedef std::vector< RenderableInstance > RenderableList;

	typedef uint32_t LargeObjectID;
	
	struct GravityGenerator 
	{
		Math::float3	position;
		float		radius;
		float		mass;
		float		maxGravityEffect;
	};
	
	

	void renderVisible( BasicMM::MicroManager & manager );

	void addNewGravityBody( Math::float3 pos, float radius, float mass, float maxGravityEffect, const RenderableInstance & ri );
}

struct Entity {
	event onCollision;
	event onDeath;
	event onDamage;
};

struct GamePosition {
	Handle Entity;		// 4 byte integer
	Math::float3 pos;		// 3 * 4 byte floats
	Math::float4 rot;		// 4 * 4 byte floats
};							// Total: 32 bytes

struct Movable {
	Math::float3 velocity;
	Math::float3 accleration;
	Handle gameposition;
};

struct Collidable {
	Handle entity;
	Handle GamePosition;
	Handle CollisionDataPrototype;
	uint32_t flags;
	uint32_t teams;
};

struct CollisionDataPrototype {
	float sphere;
	float sphereEmpty;
	float * boxes;
};

// Seperate Numbers are things in sequence.
// Same number different letter can happen at the same time
/*
//1. 	Generate: ( GamePosition + CollisionData ) --> CollisionStructure
//2.	TransForm: (CollisionStructure ) --> Collisions = {Pairs of colliding structures} 
//3.  Inform: Entity ( about Collisions )
//	3a. Transform: (GamePosition, Movable, Health) by Collisions 
//	3c.	Update: (AI, UI, NetWork)
//4. 	TransForm: ( GamePosition ) by (Movable)  --> GamePositionNew
//	4a. Cull (GamePositionNew) by CullData
//	4b.	Render --> (GamePositionNew)
//5.	GamePositionNew --> GamePosition


struct EntityVisual {
	Handle GamePosition;	
	Math::float3 cullbox;
};
// Logic:
//	For each EntityVisual 
//		1. Get gameposition
//		2. Cull based gross position
//		3. Send to render
	

// Logic:
//
// Game Loop (runs at fixed time step)
//  Game to Render --> NewUpdateTimeStep (called every 30 ms)
//		Render: -> reset internal data structures (allows render to interprolate at the current frame speed making animations smoother)
//	Game: Transform( GamePosition + EntityVisual --> CullData ) (send where the item should be at the next game loop)
// End Game Loop
// Render Loop (runs on frame time)
//  Render: Cull( CullData )
//	Render: Increment position from prior to last based on current time till next game loop 
//	Render: Update interbuffers and draw
// End Render Loop


// Updated each frame (associated with renderable)
struct CullData {
	Handle uniqueID; (Generated by using entity handle) 
	Math::Matrix worldspacetransform;
	float sphere;
	float * boxes;
};



struct GravityGenerator {
	float maxGravityRadius;
	float mass;
	Handle gameposition;
};
	



// More advanced items

struct AI {
	Handle Entity;
	Handle enemyEntity;
	State machine data;
	event onCollision;
	event onDeath;
};

struct FakeOrbitalMotion {
	Math::float3 center;
	float radius;
	float radian;
};


struct Bullet {
	// Velocity is always constant
	// Accleration is always 0
	Handle OwnerEntity;
	Handle Entity;
	Handle GamePosition;
};

struct Missle {
	// Velocity is always changing
	// Accleration is always changing
	Handle GamePosition;
	Handle TrackingEntity;
	Handle OwnerEntity;
	Handle Entity;
	// How to update a missle
	{
		1. Get current position;
		2. Get enemy position;
		3. calculat orientation difference;
		3.5 calculate distance. If too far then look for new enemyEntity 
		4. Turn by max amount;
		5. set accleration --> Movable;
	}
};

struct Explosion {
	Handle GamePosition;
	float ringSize;
	float forcePush;
	float initalDamage;
	float attenuation;
	// How to update explosion
	{
		1. Expand ringSize
		2. If initalDamage - attenuation = 0 end explosion
		3. Update collision data
		4. If collision happens store entity and ignore it for the next force push
	}
}

struct BlackHole {
	Handle Entity;
	Handle GravityGenerator;
	Handle OwnerEntity;
	float TimeToEnd;
}


}
*/